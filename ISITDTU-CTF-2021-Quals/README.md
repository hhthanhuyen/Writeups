# ISITDTU CTF QUALS 2021 - Cryptography

## one time beach

[one_time_beach.rar](one_time_beach.rar)
- cipher.enc
- one_time_beach.py
- Hint: File format JPEG

one_time_beach.py
```python
from itertools import cycle

def xor(a, b):
    return [i ^ j for i, j in zip(a, cycle(b))]

FLAG = open('flag.bin', 'rb').read()
f = open('beaches.txt', 'rb').read()

c = int(f[0x636f:0x636f+4]) & 0xff
o = int(f[0x2752298:0x2752298+4]) & 0xff
t = int(f[0x616e:0x616e+4]) & 0xff
h = int(f[0xfdeade:0xfdeade+4]) & 0xff
a = int(f[0x1a185b8:0x1a185b8+4]) & 0xff
n = int(f[0x636f74:0x636f74+4]) & 0xff
_ = int(f[0x6969:0x6969+4]) & 0xff
b = int(f[0xdeadbe:0xdeadbe+4]) & 0xff
r = int(f[0x25a5a58:0x25a5a58+4]) & 0xff
u = int(f[0x686e61:0x686e61+4]) & 0xff
i = int(f[0xbeef:0xbeef+4]) & 0xff
s = int(f[0x746f63:0x746f63+4]) & 0xff
e = int(f[0x10101:0x10101+4]) & 0xff
y = int(f[0x1fffffe:0x1fffffe+4]) & 0xff
key = [c,o,t,h,a,n,_,s,a,y,s,_,y,o,u,_,a,r,e,_,a,_,b,i,t,t,h]

cipher = xor(FLAG, key)

with open('cipher.enc', 'wb') as g:
    g.write(f[:20])
    g.write(bytearray(cipher))

```

We have flag.bin (jpg image) encrypted by XORing with a `key = [c,o,t,h,a,n,_,s,a,y,s,_,y,o,u,_,a,r,e,_,a,_,b,i,t,t,h]`, len(key) = 27. We also know 12 first bytes of a jpg format is `FF D8 FF E0 00 10 4A 46 49 46 00 01`, which reduces the number of unknown variables to 5.

The first 20 bytes of cipher.enc are “0.000000000000000000”, I didn’t get the author’s hint, turn out this challenge was about PI digits.

solve.py (Special thanks to the jpg collector - @hhtn)
```python
from itertools import cycle

def xor(a, b):
    return [i ^ j for i, j in zip(a, cycle(b))]

ct = open("cipher.enc","rb").read()
ct = ct[20:]

headers = [b'\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x01\x00H\x00H\x00\x00\xff\xfe\x00[Pho', b'\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x01\x00H\x00H\x00\x00\xff\xdb\x00\x84\x00\n\x07', b'\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x01\x00H\x00H\x00\x00\xff\xdb\x00\x84\x00\n\x07', b'\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x01\x01,\x01,\x00\x00\xff\xdb\x00\x84\x00\n\x07', b'\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x00\x00\x01\x00\x01\x00\x00\xff\xdb\x00\x84\x00\t\x06', b'\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x01\x00\xf0\x00\xf0\x00\x00\xff\xdb\x00\x84\x00\n\x07', b'\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x01\x00H\x00H\x00\x00\xff\xdb\x00C\x00\x05\x04', b'\xff\xd8\xff\xe1\x00\x18Exif\x00\x00II*\x00\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00', b'\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x00\x00\x01\x00\x01\x00\x00\xff\xdb\x00\x84\x00\t\x06', b'\xff\xd8\xff\xe1\x00\xbcExif\x00\x00II*\x00\x08\x00\x00\x00\x06\x00\x12\x01\x03\x00\x01', b'\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x00\x00\x01\x00\x01\x00\x00\xff\xdb\x00C\x00\x06\x04', b'\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x00\x00\x01\x00\x01\x00\x00\xff\xdb\x00\x84\x00\n\x07', b'\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x01\x00`\x00`\x00\x00\xff\xe1\x00JExi', b'\xff\xd8\xff\xdb\x00C\x00\x06\x04\x05\x06\x05\x04\x06\x06\x05\x06\x07\x07\x06\x08\n\x10\n\n\t\t', b'\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x00\x00\x01\x00\x01\x00\x00\xff\xe2\x02\x1cICC', b'\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x01\x00H\x00H\x00\x00\xff\xdb\x00C\x00\x08\x06', b'\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x01\x00H\x00H\x00\x00\xff\xe12\xfaExi', b'\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x00\x00\x01\x00\x01\x00\x00\xff\xdb\x00\x84\x00\t\x06', b'\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x00\x00\x01\x00\x01\x00\x00\xff\xdb\x00C\x00\x03\x02', b'\xff\xd8\xff\xe1\x0c\xd5Exif\x00\x00MM\x00*\x00\x00\x00\x08\x00\x0c\x01\x00\x00\x03\x00']

for j,i in enumerate(headers):
    key = bytes(xor(ct[:27],i))
    # print(j,key)
    f = open(f"flag{j}.jpg","wb")
    f.write(bytes(xor(ct,key)))

# flag18.jpg
```
![image](flag18.jpg)


Flag: ISITDTU{OMG_1_KNOW_PI_DIGITS}

***

## Where is your ticket?

[wheres_your_ticket.zip](wheres_your_ticket.zip)
> nc 34.125.6.66 5000

wheres_your_ticket.py
```python
from Crypto.Cipher import AES
from hashlib import md5
import hmac
from os import urandom
import sys
import random
from binascii import hexlify, unhexlify
import secret
import socket
import threading
import socketserver
import signal

host, port = '0.0.0.0', 5000
BUFF_SIZE = 1024

class ThreadedTCPServer(socketserver.ThreadingMixIn, socketserver.TCPServer):
	allow_reuse_address = True
class ThreadedTCPRequestHandler(socketserver.StreamRequestHandler):

	def handle(self):
		self.AES_BLOCK_SIZE = 32
		self.SIG_SIZE = md5().digest_size
		self.message = b'guest'
		self.key = self._hash_key(secret.key)
		self.enc_role, self.sig = self.encrypt(self.message)

		try:
			while True:
				self.menu()

				try:
					self.request.sendall(b'Your choice: ')
					opt = int(self.rfile.readline().decode())
				except ValueError:
					self.request.sendall(
						b'Invalid option!!!\n')
					continue
				if opt == 1:
					self.request.sendall(b'Data format: name=player101&role=enc_role&sign=sig, enc_role and sign are in hex.\n')
					self.request.sendall(b'Your data: ')
					data = self.rfile.readline().strip()
					self.confirm(data)
				elif opt == 2:
					self.request.sendall(b'Your data: ')
					data = self.rfile.readline().strip()
					if b'&role=' in data:
						self.request.sendall(b'Not that easy!\n')
					else:
						sign = self.sign_new(data)
						if sign == None:
							pass
						else:
							self.request.sendall(b"Hash: " + hexlify(sign) + b'\n')
				elif opt == 3:
					self.request.sendall(b'Your data: ')
					data = self.rfile.readline().strip()
					sign = self.sign_old(data)
					self.request.sendall(b"Hash: " + hexlify(sign) + b'\n')
				elif opt == 4:
					self.request.sendall(b'Goodbye!\n')
					return
				else:
					self.request.sendall(b'Invalid option!!!\n')

		except (ConnectionResetError, ConnectionAbortedError, BrokenPipeError):
			print("{} disconnected".format(self.client_address[0]))

	def menu(self):
		self.request.sendall(b'\nYour role: ' + self.decrypt(b'name=player101&role='+hexlify(self.enc_role), hexlify(self.sig)))
		self.request.sendall(b'\nEncrypted data of your role:')
		self.request.sendall(b'\nEncrypted: ' + hexlify(self.enc_role))
		self.request.sendall(b'\nSignature: ' + hexlify(self.sig) + b'\n')
		self.request.sendall(b'1. Verify your data:\n')
		self.request.sendall(b'2. Sign your data in new way:\n')
		self.request.sendall(b'3. Sign your data in old way:\n')
		self.request.sendall(b'4. Quit\n')

	def _hash_key(self, key):
		return md5(key).digest()
	
	def _initialisation_vector(self):
		return urandom(16)
	
	def _cipher(self, key, iv):
		return AES.new(key, AES.MODE_CBC, iv)

	def encrypt(self, data):
		iv = self._initialisation_vector()
		cipher = self._cipher(self.key, iv)
		pad = self.AES_BLOCK_SIZE - len(data) % self.AES_BLOCK_SIZE
		data = data + (pad * chr(pad)).encode()
		data = iv + cipher.encrypt(data)
		ss = b'name=player101&role=%s'%(hexlify(data))
		sig = self.sign_new(ss)
		return data, sig
		
	def decrypt(self, data, sig):
		if hexlify(self.sign_new(data)) != sig:
			self.request.sendall(b'Message authentication failed')
			return
		else:
			pos = data.rfind(b'&role=')
			data = unhexlify(data[pos+6:])
			iv = data[:16]
			data = data[16:]
			cipher = AES.new(self.key, AES.MODE_CBC, iv)
			data = cipher.decrypt(data)
			return data[:-data[-1]]

	def XR(self, a, b):
		len_max = len(a) if len(a) > len(b) else len(b)
		s = ''
		for i in range(len_max):
			h = hex(a[i%len(a)] ^ b[i%len(b)])[2:]
			if(len(h) < 2):
				s += '0' + hex(a[i%len(a)] ^ b[i%len(b)])[2:]
			else:
				s += hex(a[i%len(a)] ^ b[i%len(b)])[2:]
		return unhexlify(s.encode())

	def xor_key(self, a):
		if isinstance(a, str):
			a = a.encode()
		b = self.key
		s = b''
		if len(a) > len(b):
			s += self.XR(a[:len(b)], b) + a[len(b):]
		elif len(a) < len(b):
			s += self.XR(b[:len(a)], a) + b[len(a):]
		return s

	def sign_old(self, data):
		return md5(self.xor_key(data)).digest()

	def sign_new(self, data):
		return hmac.new(self.key, data, md5).digest()

	def confirm(self, data):
		if isinstance(data, str):
			data = data.encode('utf-8')
		pos_name = data.rfind(b'name=')
		pos_role = data.rfind(b'&role=')
		pos_sign = data.rfind(b'&sign=')
		if pos_role == -1 or pos_sign == -1 or pos_name == -1:
			self.request.sendall(b'\nInvalid data!\n')
			return
		enc_role = data[:pos_sign]
		sign = data[pos_sign + 6:]
		try:
			check = self.decrypt(enc_role, sign)
		except Exception:
			self.request.sendall(b'\nInvalid data!\n')
		if check == b'royal':
			self.request.sendall(b'\nFlag here: ' + secret.flag)
		elif check == b'guest':
			self.request.sendall(b'\nHello peasant!\n')
		elif check == None:
			self.request.sendall(b'\nYou\'re a intruder!!!\n')
		else:
			self.request.sendall(b'\nStranger!!!\n')

	def parse_qsl(self, query):
		m = {}
		parts = query.split(b'&')
		for part in parts:
			key, val = part.split(b'=')
			m[key] = val
		return m


def main():
	server = ThreadedTCPServer((host, port), ThreadedTCPRequestHandler)
	server_thread = threading.Thread(target=server.serve_forever)
	server_thread.daemon = True
	server_thread.start()
	print("Server loop running in thread:", server_thread.name)
	server_thread.join()

if __name__=='__main__':
	main()

```

nc 34.125.6.66 5000
```
Your role: guest
Encrypted data of your role:
Encrypted: 76f080521616b21ddd44c51c13feb31b29dc8b13b10e4c40884ab14924c85ab021cdcea06609397774681b8e390754ed
Signature: 285cd3f004e1df1516283f0dcb0d388f
1. Verify your data:
2. Sign your data in new way:
3. Sign your data in old way:
4. Quit
Your choice: 1
Data format: name=player101&role=enc_role&sign=sig, enc_role and sign are in hex.
Your data: name=player101&role=76f080521616b21ddd44c51c13feb31b29dc8b13b10e4c40884ab14924c85ab021cdcea06609397774681b8e390754ed&sign=285cd3f004e1df1516283f0dcb0d388f

Hello peasant!

Your role: guest
Encrypted data of your role:
Encrypted: 76f080521616b21ddd44c51c13feb31b29dc8b13b10e4c40884ab14924c85ab021cdcea06609397774681b8e390754ed
Signature: 285cd3f004e1df1516283f0dcb0d388f
1. Verify your data:
2. Sign your data in new way:
3. Sign your data in old way:
4. Quit
Your choice: 2
Your data: abcd
Hash: 98e44a8df981922cb53eec5322e4f449

Your role: guest
Encrypted data of your role:
Encrypted: 76f080521616b21ddd44c51c13feb31b29dc8b13b10e4c40884ab14924c85ab021cdcea06609397774681b8e390754ed
Signature: 285cd3f004e1df1516283f0dcb0d388f
1. Verify your data:
2. Sign your data in new way:
3. Sign your data in old way:
4. Quit
Your choice: 3
Your data: abcdef
Hash: f75d297d62019e64e575655a61dd29f9

[...]
```

- `Encrypted`: IV + AES_CBC("guest" + padding) <- `enc_role`
- `Signature`: sign_new(key, "name=player101&role=`enc_role`")
- The same key `[self.key = self._hash_key(secret.key)]` is used for encrypt(), decrypt(), sign_old() and sign_new().
- confirm() requires a valid `enc_role` of “royal” and a new signature [sign_new()] for that data.

```python
	def XR(self, a, b):
		len_max = len(a) if len(a) > len(b) else len(b)
		s = ''
		for i in range(len_max):
			h = hex(a[i%len(a)] ^ b[i%len(b)])[2:]
			if(len(h) < 2):
				s += '0' + hex(a[i%len(a)] ^ b[i%len(b)])[2:]
			else:
				s += hex(a[i%len(a)] ^ b[i%len(b)])[2:]
		return unhexlify(s.encode())

	def xor_key(self, a):
		if isinstance(a, str):
			a = a.encode()
		b = self.key
		s = b''
		if len(a) > len(b):
			s += self.XR(a[:len(b)], b) + a[len(b):]
		elif len(a) < len(b):
			s += self.XR(b[:len(a)], a) + b[len(a):]
		return s

	def sign_old(self, data):
		return md5(self.xor_key(data)).digest()

	def sign_new(self, data):
		return hmac.new(self.key, data, md5).digest()

	def confirm(self, data):
		if isinstance(data, str):
			data = data.encode('utf-8')
		pos_name = data.rfind(b'name=')
		pos_role = data.rfind(b'&role=')
		pos_sign = data.rfind(b'&sign=')
		if pos_role == -1 or pos_sign == -1 or pos_name == -1:
			self.request.sendall(b'\nInvalid data!\n')
			return
		enc_role = data[:pos_sign]
		sign = data[pos_sign + 6:]
		try:
			check = self.decrypt(enc_role, sign)
			print(check)
		except Exception:
			self.request.sendall(b'\nInvalid data!\n')
		if check == b'royal':
			self.request.sendall(b'\nFlag here: ' + secret.flag)
		elif check == b'guest':
			self.request.sendall(b'\nHello peasant!\n')
		elif check == None:
			self.request.sendall(b'\nYou\'re a intruder!!!\n')
		else:
			self.request.sendall(b'\nStranger!!!\n')
```

- We can make an `enc_role` for "royal" by flipping 5 bytes of IV. For the new signature, sign_old() can be used to create a valid sign_new().
- **Reference:** [Wikipedia - HMAC](https://en.wikipedia.org/wiki/HMAC)

HMAC Implementation
```
function hmac is
    input:
        key:        Bytes    // Array of bytes
        message:    Bytes    // Array of bytes to be hashed
        hash:       Function // The hash function to use (e.g. SHA-1)
        blockSize:  Integer  // The block size of the hash function (e.g. 64 bytes for SHA-1)
        outputSize: Integer  // The output size of the hash function (e.g. 20 bytes for SHA-1)
 
    // Keys longer than blockSize are shortened by hashing them
    if (length(key) > blockSize) then
        key ← hash(key) // key is outputSize bytes long

    // Keys shorter than blockSize are padded to blockSize by padding with zeros on the right
    if (length(key) < blockSize) then
        key ← Pad(key, blockSize) // Pad key with zeros to make it blockSize bytes long

    o_key_pad ← key xor [0x5c  blockSize]   // Outer padded key
    i_key_pad ← key xor [0x36  blockSize]   // Inner padded key

    return  hash(o_key_pad ∥ hash(i_key_pad ∥ message))
```

- Consider when sign_old() for `b"\x36"*64 + f"name=player101&role={enc_role}`, the server will return `hash(i_key_pad ∥ message)` due to some weird behaviors of XR() and xor_key().
- Finally, using `b"\x5c"*64 + the-previous-response` to obtain `hash(o_key_pad ∥ hash(i_key_pad ∥ message))` without knowing the key.

solve.py
```python
import hashlib
from itertools import dropwhile
from pwn import remote,xor
from hashlib import md5
import hmac

r = remote("34.125.6.66", 5000)
r.recvuntil(b"Encrypted: ")
enc_role = bytes.fromhex(r.recvline().strip().decode())
# print(enc_role.hex())
iv,ct = enc_role[:16], enc_role[16:]
iv = xor(xor(iv[:5],b"guest"),b"royal") + iv[5:]
enc_role = (iv + ct).hex()
# print(enc_role)

r.recvuntil(b"Your choice: ")
r.sendline(b"3")
r.recv()
r.sendline(b"\x36"*64 + f"name=player101&role={enc_role}".encode())
y = bytes.fromhex(r.recv().strip().split()[-1].decode())

r.recvuntil(b"Your choice: ")
r.sendline(b"3")
r.recv()
r.sendline(b"\x5c"*64 + y)
sig = r.recv().strip().split()[-1].decode()
# print(sig)

r.recvuntil(b"Your choice: ")
r.sendline(b"1")
r.recvuntil(b"Your data: ")
r.sendline(f"name=player101&role={enc_role}&sign={sig}".encode())
print(r.recv().decode())
```

Flag: ISITDTU{p34s4nts_w1LL_n0T_f1Nd_mY_S3cr3t}

***

## Matrix Crypto

[matrix-crypto.rar](matrix-crypto.rar)
- chal.sage
- output

chal.sage
```python
from hashlib import sha256
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad

flag = b"???"
flag = pad(flag, AES.block_size)

p = random_prime(2^120)
M = Matrix(GF(p),8,8)
M.randomize()
a = randint(0,p)
b = randint(0,p)
S = M^(a*b)

print(p)
print(list(M))
print(list(M^a))
print(list(M^b))

key = sha256(S.str().encode()).digest()
cipher = AES.new(key, AES.MODE_ECB)
enc = cipher.encrypt(flag)
print(enc.hex())
```

output
```
1299484232883125234475404125814289751
[(646700565399853030590113605374757156, 694794419229997542237661950166665981, 1226110546128678733946897967897086662, 782600717505831085597968274738342085, 830598218684855536000407250423288400, 607464257531039272246048166052712381, 173754830971856673387423390977178918, 536227711888523585251191764346300354), (108515742660201644719904429411354736, 983448964088017681686013070003463572, 843751259851687557778803660667696479, 1268132556546765511660504407119649361, 191653926838061251323288164955400630, 1110338795442911241498786854643585629, 33564185094224627681280604084994535, 107424875996459874472596801435599673), (486673344025614992197339422131185787, 1175142125161072738668544578437766690, 1053160610043826121813419112007204286, 154019024972556934458337221530630487, 839504791161131743389454204281722015, 908762123575504668321524344340629438, 409877706317200010728498532164576402, 272044642769946079655303888020050763), (248379519458327976345870272491793331, 26163965999662350102084931720336465, 72319098889955966620026733457934440, 961219932362313503650709200267560428, 964091328611635786319123007693578241, 63758598853659713558713630816254514, 754675091643709078512117544536965950, 1210230316140776975385320170175991642), (565059166189843320260395643658580279, 445834447200655895608632915546385652, 379679880009778357003683384918291958, 921634063201796647950584605600389287, 75656784020188772175215576581857512, 69112745556784215601389314570993886, 864205984536527609600774058815679712, 1281461341909186330565128426945269369), (1004912998359106867106410578051934907, 847704202705837871649143879431343672, 424478490246617563844292789708349391, 979625189612985109698128310012723244, 299215656712767431877157491922965194, 711624805678613402562984672843853460, 1091588844187097499642610545239112887, 658096130560046435197765326188335589), (711400605578136293809981418112316563, 940241781813520759957608876095252449, 971219504599802080715382661042236199, 495075986708274399654120274828978683, 383097099989781736332237542670833950, 630787553912026525958360154816888889, 751278645180355889413293522648861641, 476490546610731919525846067230831847), (771842095792842153954702070015337323, 247718729747916139051711947731968534, 83613512977036833887572726978889422, 84381087501169163271997847319027248, 911827947509763696036837972157747270, 1114881447767073736229234005232149555, 829842349359435964444284505198343715, 771371095248749598815125454372339566)]
[(689720645355570475163087889262221654, 304142122884955585457632213485043767, 607454684831960978848334840440876076, 768212407985189098351918740587811050, 509369841352642743410643124629435597, 628161129866681856041959573996463715, 537647239132664137134045012042692384, 403106100517792955557132479929604124), (637778514321750627637876968283590483, 1006816932462450373024359847090891892, 106096317321679143992499450654428237, 538527455560525994663481904127074272, 1298992632872355483710369519657837361, 148031202027599047657362537673972511, 1139940617911553281611102131268187227, 738113736164324348877934414611647708), (920624407291055971926004917331430100, 471120228323705587160161750921416401, 736515239541346339200728900753551671, 367129682082602266922708450793861749, 1268138960975110960890839570343771114, 1219689039609522996481298923071486592, 1093617941582042091285113822436238379, 163907760046154483058084366217877672), (453218501155319486821350367794213556, 306615358062965518438418965009160918, 1017752861220113535205106142184673084, 1100882485990828355135967074510158192, 319771834843409015182485734906396131, 53915371542314039895295460717210013, 545104076984997605173196004554344981, 925593970303870876452373758775165282), (993738500787312698864043436673864235, 29525883638523736689827126480820343, 858961356938799452382604177874690930, 447833655460699588203523795387632583, 756533142956589219796687473156803391, 761729689893921399803128515210663218, 235948222129806050181542249292584726, 625039643350105566526295209062356480), (10718960385172231857950194795701994, 639434117530030657601552537936872539, 930117547942375791895602486628112718, 1045865929260270997853109660294972039, 36250443478219005849437147423718980, 1016197067706408043718478355834908574, 463924352697278088134262594707554702, 819743634230981728773953710964005947), (912767997787558037157765676656080070, 540319993484851493591594997772928945, 958366127325898437671979634312889914, 227750787936434869705574234416470368, 1045982728533072641527921459794667639, 1169882913583112724873006100894816415, 850086860278762274104982209913771393, 334631724393403013944782326678775524), (204565344641162815333240664943599082, 309946819689910735468128475533338620, 12958285692287684684531575391554583, 261539306629062370794603682673671707, 1208177081084222752742449033912734464, 1222366699323311030199291285837154790, 176028362890261388386496333771236007, 614320581748171216367840976341290721)]
[(46812875344143291756829242244110511, 1277074527730079686919676555229396917, 705569204441125759361605509164144273, 1273706970955848164533132513141756333, 444072342519616534464907760359462086, 585114933493653041251977665249693191, 1190774850327600880051656540481418928, 748619404862075925589447492021816983), (243089533097830522039034133554667373, 648296356519133076784672469373215601, 639780737435598353045561365286954788, 994332431596244364059323621433675221, 1263069138653919142602458312005750939, 1109348352938661009916496567799654330, 978446164491616087052232487206059863, 328538627286642999666743863681393537), (862795353283801740796459871873965934, 649147382011605597367986827842799616, 789846359295404648695635104447115549, 43663979902001942649929639377838919, 291941403923398592277812697715682074, 131832097368405374819045532620141908, 252628765442845581663188107771301932, 1075053121730852391921236455944804445), (553224142439036644860739910495978366, 23884007509481447601051531471747758, 760562373444701979004494133179390083, 741356354049583431808385884162542813, 483433896281694082137882413931557883, 846832294115256837349351503915522213, 335012593309256830276111363394351433, 907629787107273327277948895938278596), (626895028044579048846560147513792425, 482896303242404988474495634581196492, 1170895600769672210406114838606789140, 108642643371418859414873561752426678, 597591385041596623371226195919241163, 923433055083785444788275262253830582, 200812435710282922561895218976555572, 702046730541448107479601604991175287), (770787083688896399946842160271997889, 798810551576122619933861073314401475, 362072125564782138428844898568420337, 225738237336837998745129632286971337, 667172629341562090658283819288154919, 1124212882620491206455863956668344002, 17441327576616477932774262401934254, 1286218466105419143193477370904747833), (1222592838371814208493808134620812325, 937782598797616101793490745430014891, 1199465260383048205211661109830435494, 1259804433539084410010784504575748391, 175241710741528762197347895089680027, 1297166754648964697609500219223865826, 901181201718963078057199698742802571, 981843735234408544726038726750813938), (952175536566787959804097537240092984, 27350174668656516195122838316831555, 575930439834348016190396519768776667, 1196457899213924622741994873341106858, 723008200630948470802642353882889360, 152204204913852175719837983812520531, 1051496865305671155813264803875165789, 619501087050167606064102821467630680)]
0a329552d58fc2e4a23d6dff940ef70acba35d8049a40e53a237d8e9b632947db2174f97b75cf6e3c0d9919945bb84d7
```

We have 3 matrices: M, M^a and M^b over GF(p). The key for AES encryption is derived from M^(a*b), by using Diffie-Hellman Key Exchange in matrices over a field.

**Reference:** [Wikipedia - Determinant](https://en.wikipedia.org/wiki/Determinant)
> **Multiplicativity and matrix groups**      
> Thus the determinant is a *multiplicative* map, i.e., for square matrices *A* and *B* of equal size, the determinant of a matrix product equals the product of their determinants:      
> det(AB) = det(A) . det(B)

Note that the map *det: GL(n, GF(p)) -> GF(p)* is not bijective because some matrices may have the same determinant. That's why discrete logarithm failed sometimes.

In this case, instead of calculating the discrete logarithm directly, I can find a secret number by using det(k*A) property.

solve.sage
```python
from hashlib import sha256
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad

p = 1299484232883125234475404125814289751
M = [(646700565399853030590113605374757156, 694794419229997542237661950166665981, 1226110546128678733946897967897086662, 782600717505831085597968274738342085, 830598218684855536000407250423288400, 607464257531039272246048166052712381, 173754830971856673387423390977178918, 536227711888523585251191764346300354), (108515742660201644719904429411354736, 983448964088017681686013070003463572, 843751259851687557778803660667696479, 1268132556546765511660504407119649361, 191653926838061251323288164955400630, 1110338795442911241498786854643585629, 33564185094224627681280604084994535, 107424875996459874472596801435599673), (486673344025614992197339422131185787, 1175142125161072738668544578437766690, 1053160610043826121813419112007204286, 154019024972556934458337221530630487, 839504791161131743389454204281722015, 908762123575504668321524344340629438, 409877706317200010728498532164576402, 272044642769946079655303888020050763), (248379519458327976345870272491793331, 26163965999662350102084931720336465, 72319098889955966620026733457934440, 961219932362313503650709200267560428, 964091328611635786319123007693578241, 63758598853659713558713630816254514, 754675091643709078512117544536965950, 1210230316140776975385320170175991642), (565059166189843320260395643658580279, 445834447200655895608632915546385652, 379679880009778357003683384918291958, 921634063201796647950584605600389287, 75656784020188772175215576581857512, 69112745556784215601389314570993886, 864205984536527609600774058815679712, 1281461341909186330565128426945269369), (1004912998359106867106410578051934907, 847704202705837871649143879431343672, 424478490246617563844292789708349391, 979625189612985109698128310012723244, 299215656712767431877157491922965194, 711624805678613402562984672843853460, 1091588844187097499642610545239112887, 658096130560046435197765326188335589), (711400605578136293809981418112316563, 940241781813520759957608876095252449, 971219504599802080715382661042236199, 495075986708274399654120274828978683, 383097099989781736332237542670833950, 630787553912026525958360154816888889, 751278645180355889413293522648861641, 476490546610731919525846067230831847), (771842095792842153954702070015337323, 247718729747916139051711947731968534, 83613512977036833887572726978889422, 84381087501169163271997847319027248, 911827947509763696036837972157747270, 1114881447767073736229234005232149555, 829842349359435964444284505198343715, 771371095248749598815125454372339566)]
A = [(689720645355570475163087889262221654, 304142122884955585457632213485043767, 607454684831960978848334840440876076, 768212407985189098351918740587811050, 509369841352642743410643124629435597, 628161129866681856041959573996463715, 537647239132664137134045012042692384, 403106100517792955557132479929604124), (637778514321750627637876968283590483, 1006816932462450373024359847090891892, 106096317321679143992499450654428237, 538527455560525994663481904127074272, 1298992632872355483710369519657837361, 148031202027599047657362537673972511, 1139940617911553281611102131268187227, 738113736164324348877934414611647708), (920624407291055971926004917331430100, 471120228323705587160161750921416401, 736515239541346339200728900753551671, 367129682082602266922708450793861749, 1268138960975110960890839570343771114, 1219689039609522996481298923071486592, 1093617941582042091285113822436238379, 163907760046154483058084366217877672), (453218501155319486821350367794213556, 306615358062965518438418965009160918, 1017752861220113535205106142184673084, 1100882485990828355135967074510158192, 319771834843409015182485734906396131, 53915371542314039895295460717210013, 545104076984997605173196004554344981, 925593970303870876452373758775165282), (993738500787312698864043436673864235, 29525883638523736689827126480820343, 858961356938799452382604177874690930, 447833655460699588203523795387632583, 756533142956589219796687473156803391, 761729689893921399803128515210663218, 235948222129806050181542249292584726, 625039643350105566526295209062356480), (10718960385172231857950194795701994, 639434117530030657601552537936872539, 930117547942375791895602486628112718, 1045865929260270997853109660294972039, 36250443478219005849437147423718980, 1016197067706408043718478355834908574, 463924352697278088134262594707554702, 819743634230981728773953710964005947), (912767997787558037157765676656080070, 540319993484851493591594997772928945, 958366127325898437671979634312889914, 227750787936434869705574234416470368, 1045982728533072641527921459794667639, 1169882913583112724873006100894816415, 850086860278762274104982209913771393, 334631724393403013944782326678775524), (204565344641162815333240664943599082, 309946819689910735468128475533338620, 12958285692287684684531575391554583, 261539306629062370794603682673671707, 1208177081084222752742449033912734464, 1222366699323311030199291285837154790, 176028362890261388386496333771236007, 614320581748171216367840976341290721)]
B = [(46812875344143291756829242244110511, 1277074527730079686919676555229396917, 705569204441125759361605509164144273, 1273706970955848164533132513141756333, 444072342519616534464907760359462086, 585114933493653041251977665249693191, 1190774850327600880051656540481418928, 748619404862075925589447492021816983), (243089533097830522039034133554667373, 648296356519133076784672469373215601, 639780737435598353045561365286954788, 994332431596244364059323621433675221, 1263069138653919142602458312005750939, 1109348352938661009916496567799654330, 978446164491616087052232487206059863, 328538627286642999666743863681393537), (862795353283801740796459871873965934, 649147382011605597367986827842799616, 789846359295404648695635104447115549, 43663979902001942649929639377838919, 291941403923398592277812697715682074, 131832097368405374819045532620141908, 252628765442845581663188107771301932, 1075053121730852391921236455944804445), (553224142439036644860739910495978366, 23884007509481447601051531471747758, 760562373444701979004494133179390083, 741356354049583431808385884162542813, 483433896281694082137882413931557883, 846832294115256837349351503915522213, 335012593309256830276111363394351433, 907629787107273327277948895938278596), (626895028044579048846560147513792425, 482896303242404988474495634581196492, 1170895600769672210406114838606789140, 108642643371418859414873561752426678, 597591385041596623371226195919241163, 923433055083785444788275262253830582, 200812435710282922561895218976555572, 702046730541448107479601604991175287), (770787083688896399946842160271997889, 798810551576122619933861073314401475, 362072125564782138428844898568420337, 225738237336837998745129632286971337, 667172629341562090658283819288154919, 1124212882620491206455863956668344002, 17441327576616477932774262401934254, 1286218466105419143193477370904747833), (1222592838371814208493808134620812325, 937782598797616101793490745430014891, 1199465260383048205211661109830435494, 1259804433539084410010784504575748391, 175241710741528762197347895089680027, 1297166754648964697609500219223865826, 901181201718963078057199698742802571, 981843735234408544726038726750813938), (952175536566787959804097537240092984, 27350174668656516195122838316831555, 575930439834348016190396519768776667, 1196457899213924622741994873341106858, 723008200630948470802642353882889360, 152204204913852175719837983812520531, 1051496865305671155813264803875165789, 619501087050167606064102821467630680)]
ct = bytes.fromhex('0a329552d58fc2e4a23d6dff940ef70acba35d8049a40e53a237d8e9b632947db2174f97b75cf6e3c0d9919945bb84d7')

M = matrix(GF(p),M)
A = matrix(GF(p),A)
B = matrix(GF(p),B)

detM, detA, detB = GF(p)(det(M)), GF(p)(det(A)), GF(p)(det(B))

A2 = 2*A
print("[+] det(A*2) = det(A) * 2^8")
detA2 = GF(p)(det(A2))
x = detA2.log(detM)
print(f"[+] det(A*2) = det(M)^{x}")

y = (GF(p)(2**8)).log(detM)
print(f"[+] 2^8 = det(M)^{y}")
a = (x - y) % (p-1)
print(f"[+] det(A) = det(M)^{a}")
print("[+] Found secret:", a)
assert A == M^a

S = B**a
key = sha256(S.str().encode()).digest()
cipher = AES.new(key, AES.MODE_ECB)
flag = unpad(cipher.decrypt(ct),16)
print(flag)
```

output
```
[+] det(A*2) = det(A) * 2^8
[+] det(A*2) = det(M)^152378183371191471912781025432779629
[+] 2^8 = det(M)^322166911989705809119315963294290626
[+] det(A) = det(M)^1129695504264610897268869187952778753
[+] Found secret: 1129695504264610897268869187952778753
b'ISITDTU{r3duc710n_70_5m4ll_0rd3r_15_p0551bl3!}'
```

Flag: ISITDTU{r3duc710n_70_5m4ll_0rd3r_15_p0551bl3!}
